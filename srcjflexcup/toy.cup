package app.gen;
import java.util.List;
import java.util.LinkedList;
import app.Node;
import app.node.*;
import app.node.binop.*;
import app.node.expr.*;
import app.node.stat.*;

// plain symbols
terminal LPAR, COMMA, RPAR, SEMI, COLON;
terminal NOT, AND, OR;
terminal PLUS, MINUS, TIMES, DIV, UMINUS;
terminal LT, LE, GT, GE;
terminal ASSIGN, RETURN, EQ, NE;

// type/statment symbols
terminal INT, BOOL, FLOAT, STRING;
terminal VOID;
terminal PROC, CORP;
terminal IF, THEN, ELIF, ELSE, FI;
terminal WHILE, DO, OD;
terminal READLN, WRITE;

// value/id symbols
terminal         NULL, TRUE, FALSE;
terminal Integer INT_CONST;
terminal Float   FLOAT_CONST;
terminal String  STRING_CONST;
terminal String ID; // Integer?

// VarDeclList
nonterminal Program;
nonterminal VarDeclList, VarDecl;
nonterminal Type;
nonterminal IdListInit;
nonterminal ExprList, Expr;
nonterminal CallProc;

// ProcList
nonterminal ProcList, Proc;
nonterminal ParamDeclList, ParDecl, IdList;
nonterminal ResultTypeList, ResultType;
nonterminal ReturnExprs;
nonterminal StatList, Stat;
nonterminal IfStat, ElifList, Elif, Else;
nonterminal WhileStat;
nonterminal ReadlnStat;
nonterminal WriteStat;
nonterminal AssignStat;

precedence left ID;
precedence left AND, OR;
precedence left LT, LE, GT, GE, EQ, NE;
precedence left TIMES, DIV, PLUS, MINUS;
precedence left NOT;
precedence left UMINUS;

Program ::= VarDeclList:vds ProcList:ps {: RESULT = new ProgramOP((LinkedList<VarDeclOP>) vds, (List<ProcOP>) ps); :};

// VarDeclList
VarDeclList ::= VarDecl:vd VarDeclList:vds {: if (vds == null) { vds = new LinkedList<VarDeclOP>(); } ((LinkedList<VarDeclOP>) vds).addFirst((VarDeclOP) vd); RESULT = vds; :}
              | /*empty*/                  {: RESULT = null; :};
VarDecl ::= Type:t IdListInit:is SEMI {: RESULT = new VarDeclOP((TypeNode) t, (IdInitOP) is); :};
Type ::= INT {: RESULT = TypeNode.INT; :}     | BOOL {: RESULT = TypeNode.BOOL; :}
       | FLOAT {: RESULT = TypeNode.FLOAT; :} | STRING {: RESULT = TypeNode.STRING; :};
IdListInit ::=                     ID:i               {: var list = new LinkedList<IdInitNode>(); list.add(new IdInitNode(new Id(i), null)); RESULT = new IdInitOP(list); :}
             |                     ID:i ASSIGN Expr:e {: var list = new LinkedList<IdInitNode>(); list.add(new IdInitNode(new Id(i), (ExprNode) e)); RESULT = new IdInitOP(list); :}
             | IdListInit:is COMMA ID:i               {: ((IdInitOP) is).getIdInits().add(new IdInitNode(new Id(i), null)); RESULT = is; :}
             | IdListInit:is COMMA ID:i ASSIGN Expr:e {: ((IdInitOP) is).getIdInits().add(new IdInitNode(new Id(i), (ExprNode) e)); RESULT = is; :};

Expr ::= NULL           {: RESULT = new Null(); :}
       | TRUE           {: RESULT = new True(); :}
       | FALSE          {: RESULT = new False(); :}
       | INT_CONST:i    {: RESULT = new IntConst(i); :}
       | FLOAT_CONST:f  {: RESULT = new FloatConst(f); :}
       | STRING_CONST:s {: RESULT = new StringConst(s); :}
       | ID:i           {: RESULT = new Id(i); :}
       | CallProc:cp {: RESULT = cp; :}
       | Expr:e1 PLUS Expr:e2  {: RESULT = new PlusOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 MINUS Expr:e2 {: RESULT = new MinusOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 TIMES Expr:e2 {: RESULT = new TimesOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 DIV Expr:e2   {: RESULT = new DivOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 AND Expr:e2 {: RESULT = new AndOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 OR Expr:e2  {: RESULT = new OrOP((ExprNode) e1, (ExprNode) e2); :}
       | NOT Expr:e          {: RESULT = new NotOP((ExprNode) e); :}
       | Expr:e1 LT Expr:e2 {: RESULT = new LTOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 LE Expr:e2 {: RESULT = new LEOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 GT Expr:e2 {: RESULT = new GTOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 GE Expr:e2 {: RESULT = new GEOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 EQ Expr:e2 {: RESULT = new EQOP((ExprNode) e1, (ExprNode) e2); :}
       | Expr:e1 NE Expr:e2 {: RESULT = new NotOP(new EQOP((ExprNode) e1, (ExprNode) e2)); :}
       | UMINUS INT_CONST:e   {: RESULT = new UMinusOP(new IntConst(-e)); :} %prec UMINUS
       | UMINUS FLOAT_CONST:e {: RESULT = new UMinusOP(new FloatConst(-e)); :}   %prec UMINUS;

CallProc ::= ID:i LPAR ExprList:es RPAR {: RESULT = new CallProcOP(new Id(i), (List<ExprNode>) es); :}
           | ID:i LPAR             RPAR {: RESULT = new CallProcOP(new Id(i), null); :};
ExprList ::= Expr:e COMMA ExprList:es {: ((LinkedList<ExprNode>) es).addFirst((ExprNode) e); RESULT = es; :}
           | Expr:e                   {: RESULT = new LinkedList<ExprNode>(); ((LinkedList<ExprNode>) RESULT).add((ExprNode) e); :};

// ProcList
ProcList ::= Proc:p ProcList:ps {: ((LinkedList<ProcOP>) ps).addFirst((ProcOP) p); RESULT = ps; :}
           | Proc:p             {: RESULT = new LinkedList<ProcOP>(); ((LinkedList<ProcOP>) RESULT).add((ProcOP) p); :};
Proc ::= PROC ID:i LPAR ParamDeclList:pds RPAR ResultTypeList:rts COLON VarDeclList:vds StatList:ss RETURN ReturnExprs:res CORP SEMI
         {: RESULT = new ProcOP(new Id(i), (List<ParDeclOP>) pds, (List<ResultTypeNode>) rts, new ProcBodyOP((List<VarDeclOP>) vds, (BodyOP) ss, (List<ExprNode>) res)); :}
       | PROC ID:i LPAR ParamDeclList:pds RPAR ResultTypeList:rts COLON VarDeclList:vds             RETURN ReturnExprs:res CORP SEMI
         {: RESULT = new ProcOP(new Id(i), (List<ParDeclOP>) pds, (List<ResultTypeNode>) rts, new ProcBodyOP((List<VarDeclOP>) vds, null, (List<ExprNode>) res)); :}
       | PROC ID:i LPAR                   RPAR ResultTypeList:rts COLON VarDeclList:vds StatList:ss RETURN ReturnExprs:res CORP SEMI
         {: RESULT = new ProcOP(new Id(i), null, (List<ResultTypeNode>) rts, new ProcBodyOP((List<VarDeclOP>) vds, (BodyOP) ss, (List<ExprNode>) res)); :}
       | PROC ID:i LPAR                   RPAR ResultTypeList:rts COLON VarDeclList:vds             RETURN ReturnExprs:res CORP SEMI
         {: RESULT = new ProcOP(new Id(i), null, (List<ResultTypeNode>) rts, new ProcBodyOP((List<VarDeclOP>) vds, null, (List<ExprNode>) res)); :};
ParamDeclList ::= ParamDeclList:pds SEMI ParDecl:pd {: ((LinkedList) pds).add(pd); RESULT = pds; :}
                | ParDecl:pd                        {: RESULT = new LinkedList(); ((LinkedList) RESULT).add(pd); :};
ParDecl ::= Type:t IdList:is {: RESULT = new ParDeclOP((TypeNode) t, (List<Id>) is); :};
IdList ::= IdList:is COMMA ID:i {: ((LinkedList<Id>) is).add(new Id(i)); RESULT = is; :}
         | ID:i                 {: RESULT = new LinkedList<Id>(); ((LinkedList<Id>) RESULT).add(new Id(i)); :};

ResultTypeList ::= ResultType:rt COMMA ResultTypeList:rts {: ((LinkedList<ResultTypeNode>) rts).addFirst((ResultTypeNode) rt); RESULT = rts; :}
                 | ResultType:rt                          {: RESULT = new LinkedList<ResultTypeNode>(); ((LinkedList<ResultTypeNode>) RESULT).add((ResultTypeNode) rt); :};
ResultType ::= Type:t {: RESULT = new ResultTypeNode((TypeNode) t); :}
             | VOID   {: RESULT = new ResultTypeNode(); :};
ReturnExprs ::= ExprList:es {: RESULT = es; :}
              | /* empty */ {: RESULT = null; :};

StatList ::= Stat:s StatList:ss {: ((LinkedList<StatNode>) ((BodyOP) ss).getStmts()).addFirst((StatNode) s); RESULT = ss; :}
           | Stat:s             {: var list = new LinkedList<StatNode>(); ((LinkedList<StatNode>) list).add((StatNode) s); RESULT = new BodyOP(list); :};
Stat ::= IfStat:is SEMI     {: RESULT = is; :}
       | WhileStat:ws SEMI  {: RESULT = ws; :}
       | AssignStat:as SEMI {: RESULT = as; :}
       | CallProc:cp SEMI   {: RESULT = new CallProcOPAdapter((CallProcOP) cp); :}
       | ReadlnStat:rs SEMI {: RESULT = rs; :}
       | WriteStat:ws SEMI  {: RESULT = ws; :};
IfStat   ::= IF Expr:e THEN StatList:ss1 ElifList:el Else:ss2 FI {: RESULT = new IfOP((ExprNode) e, (BodyOP) ss1, (LinkedList<ElifOP>) el, (BodyOP) ss2); :};
ElifList ::= Elif:e ElifList:es {: if (es == null) { es = new LinkedList<ElifOP>(); } ((LinkedList<ElifOP>) es).addFirst((ElifOP) e); RESULT = es; :}
           | /* empty */        {: RESULT = null; :};
Elif     ::= ELIF Expr:e THEN StatList:ss {: RESULT = new ElifOP((ExprNode) e, (BodyOP) ss); :};
Else     ::= ELSE StatList:ss {: RESULT = ss; :}
           | /* empty */      {: RESULT = null; :};
WhileStat ::= WHILE StatList:ss1 RETURN Expr:e DO StatList:ss2 OD {: RESULT = new WhileOP((BodyOP) ss1, (ExprNode) e, (BodyOP) ss2); :}
            | WHILE                     Expr:e DO StatList:ss  OD {: RESULT = new WhileOP(null, (ExprNode) e, (BodyOP) ss); :};
ReadlnStat ::= READLN LPAR IdList:is RPAR {: RESULT = new ReadlnOP((LinkedList<Id>) is); :};
WriteStat  ::= WRITE LPAR ExprList:es RPAR {: RESULT = new WriteOP((LinkedList<ExprNode>) es); :};
AssignStat ::= IdList:is ASSIGN ExprList:es {: RESULT = new AssignOP((LinkedList<Id>) is, (LinkedList<ExprNode>) es); :};
